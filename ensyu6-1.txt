演習問題6-1 - - - - - 

ビットマップインデックス
	特徴：
	・索引列の値が、各レコードの値に該当するか否かを表すビットマップを保持しており
	 検索処理ではビットの有無で条件に該当するか否かが判定される。
	・表のレコードをいくつかのグループに分類して管理しており、
	 グループごとにビットマップセグメントが割り当てられている。
	・値とROW_IDのStart/Endをツリー構造で持つ
	・レコードの更新のたびに、レコードロックが頻発し、更新時のメンテナンスも手間が多いので、参照用データベースであれば有用。

	長所：①ROW_IDを持たず、連続するビット値は圧縮されるため、B-Treeに比べ容量が少なくて済む。
	    ②カーディナリティの低いカラムの検索であるほど顕著にパフォーマンスが向上する
	    ③NULL, AND, OR検索ができる（NULL, ORはB-Treeでは不可）

	短所：①データの登録・更新・削除時はブロック単位でロックがかかるため、性能劣化（待機の発生）が起こりやすい
	    ②値を変更した際にその値のビットマップを0→1へ変更する必要あり
	    ③新規登録の場合はカラムが取りうる値すべてのビットマップに対してインサートが必要
	    ④同値のビットマップは圧縮されるため、セグメント単位でのロック行数が膨大になる可能性がある

ハッシュインデックス
	特徴：
	・キー値（例えばA）をハッシュ関数でハッシュ化（A'になった）した値をレコードの住所としてデータを格納する。
	・検索の際にはキー値（A）をハッシュ化して（A'になった）導き出された場所に直接アクセスする。
	・キーと値の組を書き込み、 キーを指定することで値を読み出すkey-valueストアと呼ばれる仕組み。
	・値をハッシュ化した「ハッシュインデックス」を使用する。

MySQL は 2 つの値の間におよそどのくらいの行数があるかを判断できません (これは範囲オプティマイザによって使用するインデックスを特定するために使用されます)。これは、MyISAM または InnoDB テーブルをハッシュインデックス設定された MEMORY テーブルに変更した場合に、一部のクエリーに影響することがあります。

行の検索にはキー全体のみを使用できます。(B ツリーインデックスでは、キーの任意の左端のプリフィクスを使用して行を検索できます。)

	長所：①1回の検索で検索できるので、B-Treeより高速に、一定の速度で検索可能。
	    ②インデックスキーではなく「インデックスキーのHash値」のみを格納するため、サイズの大きい型(TEXT型など)ではB-Treeより
	      インデックスのサイズが小さくなる（また、すべてのハッシュ値が同じサイズになる）。

	短所：① = または <=> 演算子を使用する等価比較にのみ使用される
	    ②値の範囲を見つける < などの比較演算子には使用されない→汎用性が低い
	    ③ORDER BY句には適用できない。
	    ④インデックスを用いた検索の後に、再度検索結果の正当性を確認する処理（Recheck処理）を
	      行う必要がある。

演習問題6-2 - - - - - 

インデックスの再編成の方法：DBMSごとに列挙
※すべてのDBMSで、インデックスの再編成が必要かを確認できる方法がある。

・Oracle Database
	コマンド：ALTER INDEX インデックス名 REBUILD;
	詳細：https://www.shift-the-oracle.com/alter-index/alter-index-rebuild.html

・SQL Server
	コマンド：ALTER INDEX インデックス名 ON データベース名.テーブル名 REBUILD;
	詳細：https://sql-oracle.com/sqlserver/?p=451#:~:text=%E8%A7%A3%E8%AA%AC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82-,SQL%20Server%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E5%86%8D%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B(%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E6%8C%87%E5%AE%9A,%EF%BD%9E%20REBUILD%E3%80%8D%E3%82%92%E4%BD%BF%E3%81%84%E3%81%BE%E3%81%99%E3%80%82	

・DB2
	コマンド：REORG TABLE テーブル名;
	詳細：https://www.ibm.com/docs/ja/db2/11.5?topic=commands-reorg-table

・PostgreSQL

	コマンド：reindex index インデックス名;
	詳細：https://qiita.com/mkyz08/items/eb66419d43c56cce566e

・MySQL

	コマンド：※インデックスをドロップしてから再作成する。
	ALTER TABLE テーブル名 DROP INDEX インデックス名 (カラム名);
	ALTER TABLE テーブル名 ADD INDEX インデックス名 (カラム名);
	詳細：https://style.potepan.com/articles/17616.html#MySQL